<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Australia Invasive Species — Interactive Map</title>

<!-- Google Maps MarkerClusterer -->
<script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>

<!-- d3 for CSV parsing and color scales -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<style>
  :root { --green: #1f9d55; }
  body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; color: #111; }
  header { padding: 16px 20px 12px; border-bottom: 1px solid #e5e7eb; }
  h1 { margin: 0 0 6px; font-size: 20px; }
  .sub { color:#555; font-size: 13px; }

  .wrap { display: grid; grid-template-rows: auto 1fr; height: calc(100vh - 68px); }
  .controls { padding: 10px 14px; border-bottom: 1px solid #e5e7eb; display: grid; grid-template-columns: 1fr auto auto auto; gap: 8px 12px; align-items: end; }
  .controls h3 { margin: 0 0 6px; font-size: 14px; color:#111; }
  .panel { margin-bottom: 0; }
  .panel label { font-size: 13px; color:#444; display:block; margin-bottom:6px; }
  .chips { display:flex; flex-wrap:wrap; gap:6px; }
  .chip { font-size: 12px; border:1px solid #d1d5db; border-radius: 999px; padding:2px 8px; cursor:pointer; user-select:none; }
  .chip.active { background: #eef7f0; border-color: var(--green); color: #0d5a2e; }
  .year-row { display:flex; gap:8px; align-items:center; }
  .legend { display:flex; flex-wrap:wrap; gap:8px 12px; }
  .legend-item { display:flex; align-items:center; gap:8px; font-size:12px; }
  .swatch { width:12px; height:12px; border-radius: 3px; }

  #map { width: 100%; height: 100%; min-height: 360px; }
  .map-wrap { position: relative; height: calc(100vh - 220px); }
  .seasonal-cta { margin: 10px 14px 0; border:1px solid #fde68a; background:#fff8e1; border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center; gap:12px; }
  .seasonal-cta h3 { margin:0; font-size:14px; color:#92400e; }
  .seasonal-cta p { margin:0; font-size:12px; color:#b45309; }
  .cta-btn { background:linear-gradient(135deg,#f59e0b,#d97706); color:#fff; border:none; padding:8px 12px; border-radius:8px; font-size:13px; font-weight:600; cursor:pointer; }
  .legend-overlay { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.9); border:1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); }

  .dot { width: 12px; height: 12px; border-radius: 50%; }

  .toolbar { display:flex; gap:8px; margin-top: 8px; }
  .btn { font-size: 12px; border:1px solid #d1d5db; background:#fff; padding:6px 10px; border-radius:8px; cursor:pointer; }
  .btn:hover { background:#f5f7f6; }
  .stat { font-size:12px; color:#555; margin-top: 6px; }

  @keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
  }
</style>
</head>
<body>
<header>
  <h1>Distribution of Australia's 5 Common Invasive Plant Species</h1>
  <div class="sub">Pins mark where species have been seen. Use the filters to choose the species and year you want to explore.</div>
  <div id="status" class="sub"></div>
 </header>

<div class="wrap">
  <div class="controls">
    <div class="panel" style="min-width:280px; grid-column: 1 / span 1;">
      <h3>Species filter</h3>
      <div id="chips" class="chips"></div>
      <div class="toolbar" style="gap:6px;">
        <button id="selectAll" class="btn" style="padding:4px 8px;">Select all</button>
        <button id="clearAll" class="btn" style="padding:4px 8px;">Clear</button>
      </div>
    </div>
    <div class="panel" style="grid-column: 2 / span 1;">
      <h3>Year range</h3>
      <div class="year-row">
        <input id="yearMin" type="number" style="width:90px">
        <span>to</span>
        <input id="yearMax" type="number" style="width:90px">
        <button id="applyYear" class="btn" style="padding:4px 8px;">Apply</button>
      </div>
      <div class="stat" id="yearStats" style="margin-top:4px;"></div>
    </div>
    <div class="panel" style="grid-column: 3 / span 1;">
      <h3>Find in my area</h3>
      <div class="year-row">
        <input id="postcode" type="text" placeholder="e.g. 3000" style="width:120px">
        <button id="findNearby" class="btn" style="padding:4px 8px;">Find</button>
      </div>
      <div class="stat" id="locationStats"></div>
    </div>
    <div class="panel" style="grid-column: 4 / span 1; text-align:right;">
      <h3>Map</h3>
      <div class="toolbar">
        <button id="resetView" class="btn">Reset view</button>
        <button id="fitToData" class="btn">Zoom to data</button>
      </div>
      <div class="stat" id="countStats"></div>
    </div>
  </div>

  <div class="seasonal-cta">
    <div>
      <h3>Seasonal Forecast</h3>
      <p>See which invasive plants are most active in your area this season.</p>
    </div>
    <button id="seasonalCTA" class="cta-btn">Get Seasonal Insights →</button>
  </div>

  <div class="map-wrap">
    <main id="map"></main>
    <div id="legendOverlay" class="legend legend-overlay"></div>
  </div>
</div>

<script>
/* ===================== DATA SOURCE SWITCH =====================
 * LOCAL (now):
 *   CONFIG.mode = "csv"
 *   CONFIG.csvUrl = "./invasive_species_combined_filtered.csv"
 *
 * AWS (later):
 *   CONFIG.mode = "json"
 *   CONFIG.jsonUrl = "https://your-api/occurrences" // returns array of objects:
 *        [{ vernacularName, decimalLatitude, decimalLongitude,
 *           eventDate, stateProvince, scientificName, country, countryCode }]
 *
 * Notes:
 *   - Enable CORS on your API.
 *   - Keep field names as above so no code changes are needed.
 * =============================================================== */
const CONFIG = {
  mode: "json",
  csvUrl: "",
  // Using backend as proxy to ALA API to avoid CORS issues
  jsonUrl: "https://invastopbackend.vercel.app/api/v1/epic1/invasive-records"
};

// The 5 plant species curated (animals removed):
const ALLOWED_SPECIES = [
  "Bitou Bush","Buffel Grass","Gamba Grass","Gorse","Lantana"
];

// Fixed species color palette (chips, legend, markers)
const SPECIES_COLORS = {
  "Bitou Bush": "#f59e0b",   // amber
  "Buffel Grass": "#10b981", // emerald
  "Gamba Grass": "#3b82f6",  // blue
  "Gorse": "#ef4444",        // red
  "Lantana": "#8b5cf6"       // violet
};
const color = (sp) => SPECIES_COLORS[sp] || "#6b7280"; // fallback slate-500

let MAP, CLUSTER, CURRENT_MARKERS = [];
const AU_CENTER = [-25.0, 134.0];
const AU_ZOOM = 4;

// UI elements
const chipsEl = document.getElementById("chips");
const legendEl = document.getElementById("legendOverlay");
const yearMinEl = document.getElementById("yearMin");
const yearMaxEl = document.getElementById("yearMax");
const yearStatsEl = document.getElementById("yearStats");
const countStatsEl = document.getElementById("countStats");
const statusEl = document.getElementById("status");
const postcodeEl = document.getElementById("postcode");
const locationStatsEl = document.getElementById("locationStats");

// State
let rawRows = [];     // original rows
let filteredRows = []; // after filters
let selectedSpecies = new Set(ALLOWED_SPECIES);
let minYear = 2015, maxYear = new Date().getFullYear(); // default from your wrangling

// --- Map setup ---
function initMap() {
  MAP = new google.maps.Map(document.getElementById('map'), {
    center: { lat: AU_CENTER[0], lng: AU_CENTER[1] },
    zoom: AU_ZOOM,
    mapTypeControl: false,
    streetViewControl: false,
  });
  // Neutral gray cluster icons to avoid confusion with species colors
  const renderer = {
    render({ count, position }) {
      const size = Math.max(28, Math.min(56, 20 + Math.log(count + 1) * 10));
      const color = "#4b5563"; // slate-600
      const svg = `\
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 44 44">\
          <circle cx="22" cy="22" r="20" fill="${color}" fill-opacity="0.85" stroke="#ffffff" stroke-width="3"/>\
          <text x="22" y="25" text-anchor="middle" font-family="system-ui, sans-serif" font-size="14" font-weight="700" fill="#ffffff">${count}</text>\
        </svg>`;
      return new google.maps.Marker({
        position,
        icon: {
          url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`,
          scaledSize: new google.maps.Size(size, size)
        },
        zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count
      });
    }
  };
  CLUSTER = new markerClusterer.MarkerClusterer({ map: MAP, markers: [], renderer });
}

function markerIcon(hex) {
  // SVG circle marker
  const svg = {
    path: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0z",
    fillColor: hex,
    fillOpacity: 1,
    strokeColor: '#ffffff',
    strokeWeight: 2,
    scale: 1,
    anchor: new google.maps.Point(8,8)
  };
  return svg;
}

// --- UI: species chips + legend ---
function renderChips() {
  chipsEl.innerHTML = "";
  ALLOWED_SPECIES.forEach(sp => {
    const div = document.createElement("div");
    div.className = "chip" + (selectedSpecies.has(sp) ? " active" : "");
    div.textContent = sp;
    div.style.borderColor = color(sp);
    div.style.boxShadow = `inset 0 0 0 2px ${color(sp)}22`;
    div.addEventListener("click", () => {
      if (selectedSpecies.has(sp)) selectedSpecies.delete(sp);
      else selectedSpecies.add(sp);
      div.classList.toggle("active");
      applyFiltersAndRender();
    });
    chipsEl.appendChild(div);
  });

  document.getElementById("selectAll").onclick = () => {
    selectedSpecies = new Set(ALLOWED_SPECIES);
    renderChips();
    applyFiltersAndRender();
  };
  document.getElementById("clearAll").onclick = () => {
    selectedSpecies.clear();
    renderChips();
    applyFiltersAndRender();
  };
  
  document.getElementById("findNearby").onclick = () => {
    const postcode = postcodeEl.value.trim();
    if (postcode) {
      findNearbyRecords(postcode);
    } else {
      locationStatsEl.textContent = "Please enter a postcode";
    }
  };
  
  // Lightweight reset: do not reload data to avoid UI hang
  document.getElementById("resetView").onclick = () => {
    MAP.setCenter({ lat: AU_CENTER[0], lng: AU_CENTER[1] });
    MAP.setZoom(AU_ZOOM);
    locationStatsEl.textContent = "";
    postcodeEl.value = "";
    // Reapply current filters to ensure markers are in sync
    applyFiltersAndRender();
  };
}

function renderLegend() {
  legendEl.innerHTML = "";
  ALLOWED_SPECIES.forEach(sp => {
    const item = document.createElement("div");
    item.className = "legend-item";
    const sw = document.createElement("div"); sw.className = "swatch"; sw.style.background = color(sp);
    const tx = document.createElement("span"); tx.textContent = sp;
    item.appendChild(sw); item.appendChild(tx);
    legendEl.appendChild(item);
  });
}

// --- Data loading ---
async function loadData() {
  if (CONFIG.mode === "json") {
    try {
      let res = await fetch(CONFIG.jsonUrl);
      if (!res.ok) {
        const altUrl = CONFIG.jsonUrl.endsWith('/') ? CONFIG.jsonUrl.slice(0, -1) : CONFIG.jsonUrl + '/';
        res = await fetch(altUrl);
      }
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      const arr = Array.isArray(json) ? json : (Array.isArray(json?.data) ? json.data : (Array.isArray(json?.records) ? json.records : []));
      if (!Array.isArray(arr)) throw new Error('Payload is not an array');
      rawRows = arr.map(d => ({
      vernacularName: String(d.vernacularName || "").trim(),
      decimalLatitude: +d.decimalLatitude,
      decimalLongitude: +d.decimalLongitude,
      eventDate: d.eventDate ? new Date(d.eventDate) : null,
      stateProvince: d.stateProvince || "",
      scientificName: d.scientificName || "",
      country: d.country || "", countryCode: d.countryCode || ""
    }));
      statusEl.textContent = `Live data loaded (${rawRows.length.toLocaleString()} rows)`;
    } catch (e) {
      console.error('Failed to fetch API data:', e);
      rawRows = [];
      statusEl.textContent = `No data available (API error: ${e.message})`;
    }
  } else {
    // CSV mode: expect your combined filtered CSV with columns you wrangled earlier
    const rows = await d3.csv(CONFIG.csvUrl, d3.autoType);
    rawRows = rows.map(d => ({
      vernacularName: String(d.vernacularName || "").trim(),
      decimalLatitude: +d.decimalLatitude,
      decimalLongitude: +d.decimalLongitude,
      // Try both: eventDate_from_parts or eventDate if you renamed it
      eventDate: d.eventDate_from_parts ? new Date(d.eventDate_from_parts) :
                 (d.eventDate ? new Date(d.eventDate) : null),
      stateProvince: d.stateProvince || "",
      scientificName: d.scientificName || "",
      country: d.country || "", countryCode: d.countryCode || ""
    }));
  }

  // Basic cleaning & limit to the 10 species
  rawRows = rawRows.filter(r =>
    ALLOWED_SPECIES.includes(r.vernacularName) &&
    Number.isFinite(r.decimalLatitude) &&
    Number.isFinite(r.decimalLongitude)
  );

  if (rawRows.length === 0) {
    countStatsEl.textContent = 'No records for current filters.';
    return;
  }

  // Infer min/max year from data (but clamp to 2015–present if needed)
  const years = rawRows
    .map(r => (r.eventDate instanceof Date && !isNaN(r.eventDate) ? r.eventDate.getFullYear() : null))
    .filter(y => y !== null);
  const yrMin = years.length ? Math.min(...years) : 2015;
  const yrMax = years.length ? Math.max(...years) : new Date().getFullYear();
  minYear = Math.max(2015, yrMin);
  // Cap the inferred max year at 2025
  maxYear = Math.min(2025, Math.max(minYear, yrMax));

  yearMinEl.value = minYear;
  yearMaxEl.value = maxYear;
  // Enforce input limits (2015–2025)
  yearMinEl.setAttribute('min', '2015');
  yearMinEl.setAttribute('max', '2025');
  yearMaxEl.setAttribute('min', '2015');
  yearMaxEl.setAttribute('max', '2025');
  yearStatsEl.textContent = `Data years: ${minYear}–${maxYear}`;
}

// --- Filtering + render markers ---
function applyFiltersAndRender() {
  const yMin = parseInt(yearMinEl.value, 10);
  // Clamp yMax to 2025 even if input tries to exceed
  const yMax = Math.min(parseInt(yearMaxEl.value, 10), 2025);
  
  // If year fields are empty, don't filter by year (show all records)
  const useYearFilter = !isNaN(yMin) && !isNaN(yMax);

  filteredRows = rawRows.filter(r => {
    if (!selectedSpecies.has(r.vernacularName)) return false;
    
    // If we're not using year filter, skip date validation
    if (!useYearFilter) return true;
    
    if (!(r.eventDate instanceof Date) || isNaN(r.eventDate)) return false;
    const y = r.eventDate.getFullYear();
    return y >= yMin && y <= yMax;
  });

  console.log('Filtering results:', {
    totalRecords: rawRows.length,
    filteredRecords: filteredRows.length,
    useYearFilter: useYearFilter,
    selectedSpecies: Array.from(selectedSpecies)
  });

  drawMarkers(filteredRows);
}

function drawMarkers(rows) {
  // Clear existing markers from clusterer
  CLUSTER.clearMarkers();

  const markers = rows.map(r => {
    const marker = new google.maps.Marker({
      position: { lat: r.decimalLatitude, lng: r.decimalLongitude },
      title: r.vernacularName,
      icon: markerIcon(color(r.vernacularName))
    });
    // Create image path for the species
    const imagePath = `/top10/${r.vernacularName.replace(/\s+/g, '')}.png`;
    
    const infowin = new google.maps.InfoWindow({
      content: `
        <div style="max-width: 300px; font-family: system-ui, sans-serif;">
          <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <img src="${imagePath}" alt="${r.vernacularName}" 
                 style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px; margin-right: 12px; border: 2px solid #e5e7eb;" 
                 onerror="this.style.display='none'">
            <div>
              <strong style="font-size: 16px; color: #1f2937;">${r.vernacularName}</strong><br/>
              <em style="color: #6b7280; font-size: 14px;">${r.scientificName || ''}</em>
            </div>
          </div>
          <div style="font-size: 14px; color: #374151;">
            <div><strong>Location:</strong> ${r.stateProvince || 'Unknown'}</div>
            <div><strong>Date:</strong> ${r.eventDate && r.eventDate instanceof Date ? r.eventDate.toISOString().slice(0,10) : (r.eventDate || 'Unknown')}</div>
            ${r.country ? `<div><strong>Country:</strong> ${r.country}</div>` : ''}
          </div>
        </div>
      `
    });
    marker.addListener('click', () => infowin.open({ map: MAP, anchor: marker }));
    return marker;
  });
  CURRENT_MARKERS = markers;
  CLUSTER.addMarkers(markers);

  countStatsEl.textContent = `Showing ${rows.length.toLocaleString()} records`;
}

// --- Wire UI buttons ---
document.getElementById("applyYear").onclick = () => applyFiltersAndRender();
document.getElementById("resetView").onclick = () => MAP.setCenter({lat: AU_CENTER[0], lng: AU_CENTER[1]}) || MAP.setZoom(AU_ZOOM);
document.getElementById("fitToData").onclick = () => {
  const bounds = new google.maps.LatLngBounds();
  if (!CURRENT_MARKERS.length) return;
  CURRENT_MARKERS.forEach(m => bounds.extend(m.getPosition()));
  MAP.fitBounds(bounds, 40);
};

// Seasonal CTA button handler (optional element)
const seasonalBtn = document.getElementById("seasonalCTA");
if (seasonalBtn) {
  seasonalBtn.onclick = () => {
    // Navigate the top-level window (not the iframe/modal)
    if (window.top) {
      window.top.location.assign('/epic5');
    } else {
      window.location.assign('/epic5');
    }
  };
}

// --- Geocoding and location functions ---
async function geocodePostcode(postcode) {
  try {
    // Use Google Geocoding API to convert postcode to coordinates
    const geocoder = new google.maps.Geocoder();
    const result = await new Promise((resolve, reject) => {
      geocoder.geocode({ address: `${postcode}, Australia` }, (results, status) => {
        if (status === 'OK' && results[0]) {
          const location = results[0].geometry.location;
          resolve({
            lat: location.lat(),
            lng: location.lng(),
            formatted_address: results[0].formatted_address
          });
        } else {
          reject(new Error(`Geocoding failed: ${status}`));
        }
      });
    });
    return result;
  } catch (error) {
    console.error('Geocoding error:', error);
    throw error;
  }
}

async function findNearbyRecords(postcode) {
  try {
    locationStatsEl.textContent = "Looking up location...";
    
    // Geocode the postcode
    const location = await geocodePostcode(postcode);
    
    // Fetch nearby records from API
    const apiUrl = `${CONFIG.jsonUrl}/near-location?latitude=${location.lat}&longitude=${location.lng}&radius_km=20`;
    const response = await fetch(apiUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    // Update the map to show only nearby records
    // Process the records to ensure proper data format
    rawRows = data.records.map(d => ({
      vernacularName: String(d.vernacularName || "").trim(),
      decimalLatitude: +d.decimalLatitude,
      decimalLongitude: +d.decimalLongitude,
      eventDate: d.eventDate ? new Date(d.eventDate) : null,
      stateProvince: d.stateProvince || "",
      scientificName: d.scientificName || "",
      country: d.country || "", 
      countryCode: d.countryCode || ""
    }));
    
    // Debug logging
    console.log('Nearby records loaded:', rawRows.length);
    console.log('Sample record:', rawRows[0]);
    
    // Reset year filters to show all years for nearby records
    yearMinEl.value = '';
    yearMaxEl.value = '';
    
    // Apply filters and render
    applyFiltersAndRender();
    
    // Center map on the location
    MAP.setCenter({ lat: location.lat, lng: location.lng });
    MAP.setZoom(10);
    
    // Update status
    locationStatsEl.textContent = `Found ${data.total_count} records within 20km of ${postcode}`;
    statusEl.textContent = `Showing ${data.total_count} records near ${postcode}`;
    
  } catch (error) {
    console.error('Error finding nearby records:', error);
    locationStatsEl.textContent = `Error: ${error.message}`;
  }
}

// --- Init everything ---
(async function main() {
  // Load Google Maps using API key from ?key= query param or #key= hash
  const params = new URLSearchParams(location.search);
  let apiKey = params.get('key');
  if (!apiKey && location.hash) {
    const hash = location.hash.startsWith('#') ? location.hash.slice(1) : location.hash;
    const hashParams = new URLSearchParams(hash);
    apiKey = hashParams.get('key');
  }
  const apiOverride = params.get('api');
  if (apiOverride) CONFIG.jsonUrl = apiOverride;
  if (!apiKey) {
    document.getElementById('map').innerHTML = '<div style="padding:16px">Missing Google Maps API key (?key=...)</div>';
    return;
  }
  await new Promise((resolve) => {
    const s = document.createElement('script');
    s.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}`;
    s.async = true; s.defer = true; s.onload = resolve; document.head.appendChild(s);
  });
  initMap();
  renderChips();
  renderLegend();
  await loadData();
  applyFiltersAndRender();
})();
</script>
</body>
</html>
