<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Australia Invasive Species — Interactive Map</title>

<!-- Google Maps MarkerClusterer -->
<script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>

<!-- d3 for CSV parsing and color scales -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<style>
  :root { --green: #1f9d55; }
  body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; color: #111; }
  header { padding: 16px 20px 12px; border-bottom: 1px solid #e5e7eb; }
  h1 { margin: 0 0 6px; font-size: 20px; }
  .sub { color:#555; font-size: 13px; }

  .wrap { display: grid; grid-template-rows: auto 1fr; height: calc(100vh - 68px); }
  .controls { 
    padding: 8px 12px; 
    border-bottom: 1px solid #e5e7eb; 
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    display: grid; 
    grid-template-columns: 1fr auto auto auto; 
    gap: 8px 12px; 
    align-items: start; 
  }
  .controls h3 { 
    margin: 0 0 4px; 
    font-size: 13px; 
    color: #1e293b; 
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .panel { 
    margin-bottom: 0; 
    background: rgba(255, 255, 255, 0.8);
    border-radius: 6px;
    padding: 6px;
    border: 1px solid rgba(226, 232, 240, 0.8);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }
  .panel label { font-size: 13px; color:#444; display:block; margin-bottom:6px; }
  .chips { display:flex; flex-wrap:wrap; gap:4px; margin-bottom: 4px; }
  .chip { 
    font-size: 11px; 
    font-weight: 500;
    border: 1px solid #e5e7eb; 
    border-radius: 12px; 
    padding: 3px 8px; 
    cursor: pointer; 
    user-select: none; 
    transition: all 0.2s ease;
    position: relative;
    background: #ffffff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .chip:hover { 
    transform: translateY(-1px); 
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .chip.active { 
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    border-color: var(--green); 
    color: #0d5a2e; 
    font-weight: 600;
    box-shadow: 0 2px 8px rgba(31, 157, 85, 0.2);
  }
  .chip.active::before {
    content: '✓';
    position: absolute;
    top: -2px;
    right: -2px;
    background: var(--green);
    color: white;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: bold;
  }
  .year-row { display:flex; gap:6px; align-items:center; }
  .legend { display:flex; flex-wrap:wrap; gap:8px 12px; }
  .legend-item { display:flex; align-items:center; gap:8px; font-size:12px; }
  .swatch { width:12px; height:12px; border-radius: 3px; }

  #map { width: 100%; height: 100%; min-height: 360px; }
  .map-wrap { position: relative; height: calc(100vh - 220px); }
  .seasonal-cta { margin: 10px 14px 0; border:1px solid #fde68a; background:#fff8e1; border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center; gap:12px; }
  .seasonal-cta h3 { margin:0; font-size:14px; color:#92400e; }
  .seasonal-cta p { margin:0; font-size:12px; color:#b45309; }
  .cta-btn { background:linear-gradient(135deg,#f59e0b,#d97706); color:#fff; border:none; padding:8px 12px; border-radius:8px; font-size:13px; font-weight:600; cursor:pointer; }
  .legend-overlay { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.9); border:1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); }

  .dot { width: 12px; height: 12px; border-radius: 50%; }

  .toolbar { display:flex; gap:6px; margin-top: 4px; }
  .btn { 
    font-size: 10px; 
    font-weight: 500;
    border: 1px solid #d1d5db; 
    background: #fff; 
    padding: 4px 8px; 
    border-radius: 6px; 
    cursor: pointer; 
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .btn:hover { 
    background: #f8fafc; 
    border-color: #94a3b8;
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  .stat { font-size:11px; color:#555; margin-top: 4px; }

  /* Custom zoom controls positioned on map */
  .zoom-controls { position: absolute; top: 12px; left: 12px; z-index: 1000; }
  .zoom-btn { 
    display: block; 
    width: 40px; 
    height: 40px; 
    background: #fff; 
    border: 1px solid #d1d5db; 
    border-radius: 4px; 
    cursor: pointer; 
    font-size: 18px; 
    font-weight: bold; 
    color: #374151; 
    margin-bottom: 2px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: all 0.2s;
  }
  .zoom-btn:hover { 
    background: #f9fafb; 
    border-color: #9ca3af; 
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  .zoom-btn:active { 
    background: #e5e7eb; 
    transform: scale(0.95);
  }

  @keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
  }
</style>
</head>
<body>
<header>
  <h1>Distribution of Australia's 5 Common Invasive Plant Species</h1>
  <div class="sub">Pins mark where species have been seen. Use the filters to choose the species and year you want to explore.</div>
  <div id="status" class="sub"></div>
 </header>

<div class="wrap">
  <div class="controls">
    <div class="panel" style="min-width:280px; grid-column: 1 / span 1;">
      <h3>Species filter</h3>
      <div id="chips" class="chips"></div>
      <div class="toolbar" style="gap:6px;">
        <button id="selectAll" class="btn" style="padding:4px 8px;">Select all</button>
        <button id="clearAll" class="btn" style="padding:4px 8px;">Clear</button>
      </div>
    </div>
    <div class="panel" style="grid-column: 2 / span 1;">
      <h3>Year range</h3>
      <div class="year-row">
        <input id="yearMin" type="number" style="width:90px">
        <span>to</span>
        <input id="yearMax" type="number" style="width:90px">
        <button id="applyYear" class="btn" style="padding:4px 8px;">Apply</button>
      </div>
      <div class="stat" id="yearStats" style="margin-top:4px;"></div>
    </div>
    <div class="panel" style="grid-column: 3 / span 1;">
      <h3>Find in my area</h3>
      <div class="year-row">
        <input id="postcode" type="text" placeholder="e.g. 3000" style="width:120px">
        <button id="findNearby" class="btn" style="padding:4px 8px;">Find</button>
      </div>
      <div class="stat" id="locationStats"></div>
    </div>
    <div class="panel" style="grid-column: 4 / span 1; text-align:right;">
      <h3>Map</h3>
      <div class="stat" id="countStats"></div>
    </div>
  </div>

  <div class="seasonal-cta">
    <div>
      <h3>Seasonal Forecast</h3>
      <p>See which invasive plants are most active in your area this season.</p>
    </div>
    <button id="seasonalCTA" class="cta-btn">Get Seasonal Insights →</button>
  </div>

  <div class="map-wrap">
    <main id="map"></main>
    <div id="legendOverlay" class="legend legend-overlay"></div>
    <!-- Custom zoom controls positioned on map -->
    <div class="zoom-controls">
      <button id="zoomIn" class="zoom-btn">+</button>
      <button id="zoomOut" class="zoom-btn">−</button>
    </div>
  </div>
</div>

<script>
/* ===================== DATA SOURCE SWITCH =====================
 * LOCAL (now):
 *   CONFIG.mode = "csv"
 *   CONFIG.csvUrl = "./invasive_species_combined_filtered.csv"
 *
 * AWS (later):
 *   CONFIG.mode = "json"
 *   CONFIG.jsonUrl = "https://your-api/occurrences" // returns array of objects:
 *        [{ vernacularName, decimalLatitude, decimalLongitude,
 *           eventDate, stateProvince, scientificName, country, countryCode }]
 *
 * Notes:
 *   - Enable CORS on your API.
 *   - Keep field names as above so no code changes are needed.
 * =============================================================== */
const CONFIG = {
  mode: "json",
  csvUrl: "",
  // Using backend as proxy to ALA API to avoid CORS issues
  jsonUrl: "https://invastopbackend.vercel.app/api/v1/epic1/invasive-records"
};

// The 5 plant species curated (animals removed):
const ALLOWED_SPECIES = [
  "Bitou Bush","Buffel Grass","Gamba Grass","Gorse","Lantana"
];

// Fixed species color palette (chips, legend, markers)
const SPECIES_COLORS = {
  "Bitou Bush": "#f59e0b",   // amber
  "Buffel Grass": "#10b981", // emerald
  "Gamba Grass": "#3b82f6",  // blue
  "Gorse": "#ef4444",        // red
  "Lantana": "#8b5cf6"       // violet
};
const color = (sp) => SPECIES_COLORS[sp] || "#6b7280"; // fallback slate-500

let MAP, CLUSTER, CURRENT_MARKERS = [];
const AU_CENTER = [-25.0, 134.0];
const AU_ZOOM = 4;

// UI elements
const chipsEl = document.getElementById("chips");
const legendEl = document.getElementById("legendOverlay");
const yearMinEl = document.getElementById("yearMin");
const yearMaxEl = document.getElementById("yearMax");
const yearStatsEl = document.getElementById("yearStats");
const countStatsEl = document.getElementById("countStats");
const statusEl = document.getElementById("status");
const postcodeEl = document.getElementById("postcode");
const locationStatsEl = document.getElementById("locationStats");

// State
let rawRows = [];     // original rows
let filteredRows = []; // after filters
let selectedSpecies = new Set(ALLOWED_SPECIES);
let minYear = 2015, maxYear = new Date().getFullYear(); // default from your wrangling

// --- Map setup ---
function initMap() {
  MAP = new google.maps.Map(document.getElementById('map'), {
    center: { lat: AU_CENTER[0], lng: AU_CENTER[1] },
    zoom: AU_ZOOM,
    mapTypeControl: false,
    streetViewControl: false,
  });
  // Neutral gray cluster icons to avoid confusion with species colors
  const renderer = {
    render({ count, position }) {
      const size = Math.max(28, Math.min(56, 20 + Math.log(count + 1) * 10));
      const color = "#4b5563"; // slate-600
      const svg = `\
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 44 44">\
          <circle cx="22" cy="22" r="20" fill="${color}" fill-opacity="0.85" stroke="#ffffff" stroke-width="3"/>\
          <text x="22" y="25" text-anchor="middle" font-family="system-ui, sans-serif" font-size="14" font-weight="700" fill="#ffffff">${count}</text>\
        </svg>`;
      return new google.maps.Marker({
        position,
        icon: {
          url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`,
          scaledSize: new google.maps.Size(size, size)
        },
        zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count
      });
    }
  };
  CLUSTER = new markerClusterer.MarkerClusterer({ map: MAP, markers: [], renderer });
}

function markerIcon(hex) {
  // SVG circle marker
  const svg = {
    path: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0z",
    fillColor: hex,
    fillOpacity: 1,
    strokeColor: '#ffffff',
    strokeWeight: 2,
    scale: 1,
    anchor: new google.maps.Point(8,8)
  };
  return svg;
}

// --- UI: species chips + legend ---
function renderChips() {
  chipsEl.innerHTML = "";
  
  ALLOWED_SPECIES.forEach(sp => {
    const div = document.createElement("div");
    div.className = "chip" + (selectedSpecies.has(sp) ? " active" : "");
    div.textContent = sp;
    
    // Enhanced styling with species-specific colors
    const speciesColor = color(sp);
    div.style.borderColor = selectedSpecies.has(sp) ? speciesColor : "#e5e7eb";
    div.style.color = selectedSpecies.has(sp) ? speciesColor : "#374151";
    
    if (selectedSpecies.has(sp)) {
      div.style.background = `linear-gradient(135deg, ${speciesColor}15 0%, ${speciesColor}25 100%)`;
      div.style.boxShadow = `0 2px 8px ${speciesColor}30`;
    } else {
      div.style.background = "#ffffff";
      div.style.boxShadow = "0 1px 3px rgba(0,0,0,0.1)";
    }
    
    div.addEventListener("click", () => {
      if (selectedSpecies.has(sp)) {
        selectedSpecies.delete(sp);
      } else {
        selectedSpecies.add(sp);
      }
      
      // Update visual state immediately
      div.classList.toggle("active");
      const isActive = selectedSpecies.has(sp);
      div.style.borderColor = isActive ? speciesColor : "#e5e7eb";
      div.style.color = isActive ? speciesColor : "#374151";
      
      if (isActive) {
        div.style.background = `linear-gradient(135deg, ${speciesColor}15 0%, ${speciesColor}25 100%)`;
        div.style.boxShadow = `0 2px 8px ${speciesColor}30`;
      } else {
        div.style.background = "#ffffff";
        div.style.boxShadow = "0 1px 3px rgba(0,0,0,0.1)";
      }
      
      // Apply filters with visual feedback
      applyFiltersAndRender();
      
      // Add brief visual feedback
      div.style.transform = "scale(0.95)";
      setTimeout(() => {
        div.style.transform = "";
      }, 150);
    });
    
    chipsEl.appendChild(div);
  });

  document.getElementById("selectAll").onclick = () => {
    selectedSpecies = new Set(ALLOWED_SPECIES);
    renderChips();
    applyFiltersAndRender();
    
    // Visual feedback
    const btn = document.getElementById("selectAll");
    btn.style.background = "#10b981";
    btn.style.color = "white";
    setTimeout(() => {
      btn.style.background = "";
      btn.style.color = "";
    }, 300);
  };
  
  document.getElementById("clearAll").onclick = () => {
    selectedSpecies.clear();
    renderChips();
    applyFiltersAndRender();
    
    // Visual feedback
    const btn = document.getElementById("clearAll");
    btn.style.background = "#ef4444";
    btn.style.color = "white";
    setTimeout(() => {
      btn.style.background = "";
      btn.style.color = "";
    }, 300);
  };
  
  document.getElementById("findNearby").onclick = () => {
    const postcode = postcodeEl.value.trim();
    if (postcode) {
      findNearbyRecords(postcode);
    } else {
      locationStatsEl.textContent = "Please enter a postcode";
      locationStatsEl.style.color = "#ef4444";
    }
  };
  
  // Note: resetView button removed, zoom controls added instead
}

function renderLegend() {
  legendEl.innerHTML = "";
  ALLOWED_SPECIES.forEach(sp => {
    const item = document.createElement("div");
    item.className = "legend-item";
    const sw = document.createElement("div"); sw.className = "swatch"; sw.style.background = color(sp);
    const tx = document.createElement("span"); tx.textContent = sp;
    item.appendChild(sw); item.appendChild(tx);
    legendEl.appendChild(item);
  });
}

// --- Data loading ---
async function loadData() {
  if (CONFIG.mode === "json") {
    try {
      let res = await fetch(CONFIG.jsonUrl);
      if (!res.ok) {
        const altUrl = CONFIG.jsonUrl.endsWith('/') ? CONFIG.jsonUrl.slice(0, -1) : CONFIG.jsonUrl + '/';
        res = await fetch(altUrl);
      }
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      const arr = Array.isArray(json) ? json : (Array.isArray(json?.data) ? json.data : (Array.isArray(json?.records) ? json.records : []));
      if (!Array.isArray(arr)) throw new Error('Payload is not an array');
      rawRows = arr.map(d => ({
      vernacularName: String(d.vernacularName || "").trim(),
      decimalLatitude: +d.decimalLatitude,
      decimalLongitude: +d.decimalLongitude,
      eventDate: d.eventDate ? new Date(d.eventDate) : null,
      stateProvince: d.stateProvince || "",
      scientificName: d.scientificName || "",
      country: d.country || "", countryCode: d.countryCode || ""
    }));
      statusEl.textContent = `Live data loaded (${rawRows.length.toLocaleString()} rows)`;
    } catch (e) {
      console.error('Failed to fetch API data:', e);
      rawRows = [];
      statusEl.textContent = `No data available (API error: ${e.message})`;
    }
  } else {
    // CSV mode: expect your combined filtered CSV with columns you wrangled earlier
    const rows = await d3.csv(CONFIG.csvUrl, d3.autoType);
    rawRows = rows.map(d => ({
      vernacularName: String(d.vernacularName || "").trim(),
      decimalLatitude: +d.decimalLatitude,
      decimalLongitude: +d.decimalLongitude,
      // Try both: eventDate_from_parts or eventDate if you renamed it
      eventDate: d.eventDate_from_parts ? new Date(d.eventDate_from_parts) :
                 (d.eventDate ? new Date(d.eventDate) : null),
      stateProvince: d.stateProvince || "",
      scientificName: d.scientificName || "",
      country: d.country || "", countryCode: d.countryCode || ""
    }));
  }

  // Basic cleaning & limit to allowed species + enforce 2015+ date filter
  rawRows = rawRows.filter(r => {
    // Check species
    if (!ALLOWED_SPECIES.includes(r.vernacularName)) return false;
    
    // Check coordinates
    if (!Number.isFinite(r.decimalLatitude) || !Number.isFinite(r.decimalLongitude)) return false;
    
    // CRITICAL: Filter out any data prior to 2015 at the source
    if (r.eventDate instanceof Date && !isNaN(r.eventDate)) {
      const year = r.eventDate.getFullYear();
      if (year < 2015) {
        console.log(`Excluding record from ${year} (prior to 2015):`, r.vernacularName);
        return false;
      }
    }
    
    return true;
  });

  if (rawRows.length === 0) {
    countStatsEl.textContent = 'No records for current filters.';
    return;
  }

  // Infer min/max year from data (enforce 2015+ constraint)
  const years = rawRows
    .map(r => (r.eventDate instanceof Date && !isNaN(r.eventDate) ? r.eventDate.getFullYear() : null))
    .filter(y => y !== null && y >= 2015); // Only consider years 2015+
  
  const currentYear = new Date().getFullYear();
  const yrMin = years.length ? Math.min(...years) : 2015;
  const yrMax = years.length ? Math.max(...years) : currentYear;
  
  // Enforce constraints: min 2015, max current year
  minYear = Math.max(2015, yrMin);
  maxYear = Math.min(currentYear, Math.max(minYear, yrMax));
  
  console.log('Year range inferred:', {
    availableYears: years.length,
    yrMin, yrMax,
    finalRange: `${minYear}-${maxYear}`,
    currentYear
  });

  yearMinEl.value = minYear;
  yearMaxEl.value = maxYear;
  // Enforce input limits (2015–2025)
  yearMinEl.setAttribute('min', '2015');
  yearMinEl.setAttribute('max', '2025');
  yearMaxEl.setAttribute('min', '2015');
  yearMaxEl.setAttribute('max', '2025');
  yearStatsEl.textContent = `Data years: ${minYear}–${maxYear}`;
}

// --- Filtering + render markers ---
function applyFiltersAndRender() {
  // Parse year inputs with robust validation
  let yMin, yMax;
  const minInput = yearMinEl.value.trim();
  const maxInput = yearMaxEl.value.trim();
  
  // Parse year values with validation
  if (minInput === '' || maxInput === '') {
    // If either field is empty, use default range (2015 to current year)
    yMin = 2015;
    yMax = new Date().getFullYear();
  } else {
    yMin = parseInt(minInput, 10);
    yMax = parseInt(maxInput, 10);
    
    // Validate parsed years
    if (isNaN(yMin) || isNaN(yMax)) {
      console.warn('Invalid year input detected, using default range');
      yMin = 2015;
      yMax = new Date().getFullYear();
    }
  }
  
  // Enforce minimum year of 2015 (no data prior to 2015 allowed)
  yMin = Math.max(2015, yMin);
  yMax = Math.min(new Date().getFullYear(), Math.max(yMin, yMax));
  
  // Update input fields to reflect enforced values
  yearMinEl.value = yMin;
  yearMaxEl.value = yMax;
  
  console.log('Year filter applied:', { yMin, yMax });

  filteredRows = rawRows.filter(r => {
    // Filter by species - ensure we have valid species data
    if (!r.vernacularName || !selectedSpecies.has(r.vernacularName)) {
      return false;
    }
    
    // Always filter out data prior to 2015, regardless of user input
    if (!(r.eventDate instanceof Date) || isNaN(r.eventDate)) {
      return false; // Exclude records without valid dates
    }
    
    const year = r.eventDate.getFullYear();
    
    // Critical: Never show data prior to 2015
    if (year < 2015) {
      return false;
    }
    
    // Apply user's year range filter
    const yearInRange = year >= yMin && year <= yMax;
    
    // Additional validation for coordinates
    const hasValidCoords = Number.isFinite(r.decimalLatitude) && 
                          Number.isFinite(r.decimalLongitude) &&
                          r.decimalLatitude >= -90 && r.decimalLatitude <= 90 &&
                          r.decimalLongitude >= -180 && r.decimalLongitude <= 180;
    
    return yearInRange && hasValidCoords;
  });

  // Enhanced logging with detailed breakdown
  const speciesBreakdown = {};
  ALLOWED_SPECIES.forEach(sp => {
    speciesBreakdown[sp] = filteredRows.filter(r => r.vernacularName === sp).length;
  });
  
  console.log('Filtering results:', {
    totalRecords: rawRows.length,
    filteredRecords: filteredRows.length,
    yearRange: `${yMin}-${yMax}`,
    selectedSpecies: Array.from(selectedSpecies),
    speciesBreakdown: speciesBreakdown,
    recordsExcludedBefore2015: rawRows.filter(r => {
      if (!(r.eventDate instanceof Date) || isNaN(r.eventDate)) return false;
      return r.eventDate.getFullYear() < 2015;
    }).length,
    invalidCoordinates: rawRows.filter(r => {
      return !Number.isFinite(r.decimalLatitude) || !Number.isFinite(r.decimalLongitude) ||
             r.decimalLatitude < -90 || r.decimalLatitude > 90 ||
             r.decimalLongitude < -180 || r.decimalLongitude > 180;
    }).length
  });

  drawMarkers(filteredRows);
}

function drawMarkers(rows) {
  // Clear existing markers from clusterer
  CLUSTER.clearMarkers();

  const markers = rows.map(r => {
    const marker = new google.maps.Marker({
      position: { lat: r.decimalLatitude, lng: r.decimalLongitude },
      title: r.vernacularName,
      icon: markerIcon(color(r.vernacularName))
    });
    // Create image path for the species
    const imagePath = `/top10/${r.vernacularName.replace(/\s+/g, '')}.png`;
    
    const infowin = new google.maps.InfoWindow({
      content: `
        <div style="max-width: 300px; font-family: system-ui, sans-serif;">
          <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <img src="${imagePath}" alt="${r.vernacularName}" 
                 style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px; margin-right: 12px; border: 2px solid #e5e7eb;" 
                 onerror="this.style.display='none'">
            <div>
              <strong style="font-size: 16px; color: #1f2937;">${r.vernacularName}</strong><br/>
              <em style="color: #6b7280; font-size: 14px;">${r.scientificName || ''}</em>
            </div>
          </div>
          <div style="font-size: 14px; color: #374151;">
            <div><strong>Location:</strong> ${r.stateProvince || 'Unknown'}</div>
            <div><strong>Date:</strong> ${r.eventDate && r.eventDate instanceof Date ? r.eventDate.toISOString().slice(0,10) : (r.eventDate || 'Unknown')}</div>
            ${r.country ? `<div><strong>Country:</strong> ${r.country}</div>` : ''}
          </div>
        </div>
      `
    });
    marker.addListener('click', () => infowin.open({ map: MAP, anchor: marker }));
    return marker;
  });
  CURRENT_MARKERS = markers;
  CLUSTER.addMarkers(markers);

  // Enhanced count display with more context
  const selectedCount = selectedSpecies.size;
  const totalSpecies = ALLOWED_SPECIES.length;
  countStatsEl.textContent = `Showing ${rows.length.toLocaleString()} records`;
  
  // Add tooltip-like information
  countStatsEl.title = `Filtered from ${rawRows.length.toLocaleString()} total records\n${selectedCount} of ${totalSpecies} species selected`;
}

// --- Wire UI buttons ---
document.getElementById("applyYear").onclick = () => applyFiltersAndRender();

// Add input validation for year fields
function validateYearInput(input, isMin = true) {
  const value = parseInt(input.value, 10);
  const currentYear = new Date().getFullYear();
  
  if (isNaN(value)) {
    input.value = isMin ? '2015' : currentYear.toString();
    return;
  }
  
  // Enforce minimum year of 2015
  if (value < 2015) {
    input.value = '2015';
    return;
  }
  
  // Enforce maximum year of current year
  if (value > currentYear) {
    input.value = currentYear.toString();
    return;
  }
  
  // For min input, ensure it doesn't exceed max
  if (isMin && yearMaxEl.value && parseInt(yearMaxEl.value, 10) < value) {
    input.value = yearMaxEl.value;
    return;
  }
  
  // For max input, ensure it doesn't go below min
  if (!isMin && yearMinEl.value && parseInt(yearMinEl.value, 10) > value) {
    input.value = yearMinEl.value;
    return;
  }
}

// Add event listeners for real-time validation
yearMinEl.addEventListener('input', () => validateYearInput(yearMinEl, true));
yearMinEl.addEventListener('blur', () => validateYearInput(yearMinEl, true));
yearMaxEl.addEventListener('input', () => validateYearInput(yearMaxEl, false));
yearMaxEl.addEventListener('blur', () => validateYearInput(yearMaxEl, false));

// Add Enter key support for year inputs
yearMinEl.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    validateYearInput(yearMinEl, true);
    applyFiltersAndRender();
  }
});

yearMaxEl.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    validateYearInput(yearMaxEl, false);
    applyFiltersAndRender();
  }
});

// Custom zoom controls positioned on map
document.getElementById("zoomIn").onclick = () => {
  if (MAP) {
    const currentZoom = MAP.getZoom();
    MAP.setZoom(currentZoom + 1);
  }
};

document.getElementById("zoomOut").onclick = () => {
  if (MAP) {
    const currentZoom = MAP.getZoom();
    MAP.setZoom(currentZoom - 1);
  }
};

// Seasonal CTA button handler (optional element)
const seasonalBtn = document.getElementById("seasonalCTA");
if (seasonalBtn) {
  seasonalBtn.onclick = () => {
    // Navigate the top-level window (not the iframe/modal)
    if (window.top) {
      window.top.location.assign('/epic5');
    } else {
      window.location.assign('/epic5');
    }
  };
}

// --- Geocoding and location functions ---
async function geocodePostcode(postcode) {
  try {
    // Use Google Geocoding API to convert postcode to coordinates
    const geocoder = new google.maps.Geocoder();
    const result = await new Promise((resolve, reject) => {
      geocoder.geocode({ address: `${postcode}, Australia` }, (results, status) => {
        if (status === 'OK' && results[0]) {
          const location = results[0].geometry.location;
          resolve({
            lat: location.lat(),
            lng: location.lng(),
            formatted_address: results[0].formatted_address
          });
        } else {
          reject(new Error(`Geocoding failed: ${status}`));
        }
      });
    });
    return result;
  } catch (error) {
    console.error('Geocoding error:', error);
    throw error;
  }
}

async function findNearbyRecords(postcode) {
  try {
    locationStatsEl.textContent = "Looking up location...";
    
    // Geocode the postcode
    const location = await geocodePostcode(postcode);
    
    // Fetch nearby records from API
    const apiUrl = `${CONFIG.jsonUrl}/near-location?latitude=${location.lat}&longitude=${location.lng}&radius_km=20`;
    const response = await fetch(apiUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    // Update the map to show only nearby records
    // Process the records to ensure proper data format
    rawRows = data.records.map(d => ({
      vernacularName: String(d.vernacularName || "").trim(),
      decimalLatitude: +d.decimalLatitude,
      decimalLongitude: +d.decimalLongitude,
      eventDate: d.eventDate ? new Date(d.eventDate) : null,
      stateProvince: d.stateProvince || "",
      scientificName: d.scientificName || "",
      country: d.country || "", 
      countryCode: d.countryCode || ""
    }));
    
    // Debug logging
    console.log('Nearby records loaded:', rawRows.length);
    console.log('Sample record:', rawRows[0]);
    
    // Reset year filters to show all years for nearby records
    yearMinEl.value = '';
    yearMaxEl.value = '';
    
    // Apply filters and render
    applyFiltersAndRender();
    
    // Center map on the location
    MAP.setCenter({ lat: location.lat, lng: location.lng });
    MAP.setZoom(10);
    
    // Update status
    locationStatsEl.textContent = `Found ${data.total_count} records within 20km of ${postcode}`;
    statusEl.textContent = `Showing ${data.total_count} records near ${postcode}`;
    
  } catch (error) {
    console.error('Error finding nearby records:', error);
    locationStatsEl.textContent = `Error: ${error.message}`;
  }
}

// --- Init everything ---
(async function main() {
  // Load Google Maps using API key from ?key= query param or #key= hash
  const params = new URLSearchParams(location.search);
  let apiKey = params.get('key');
  if (!apiKey && location.hash) {
    const hash = location.hash.startsWith('#') ? location.hash.slice(1) : location.hash;
    const hashParams = new URLSearchParams(hash);
    apiKey = hashParams.get('key');
  }
  const apiOverride = params.get('api');
  if (apiOverride) CONFIG.jsonUrl = apiOverride;
  if (!apiKey) {
    document.getElementById('map').innerHTML = '<div style="padding:16px">Missing Google Maps API key (?key=...)</div>';
    return;
  }
  await new Promise((resolve) => {
    const s = document.createElement('script');
    s.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}`;
    s.async = true; s.defer = true; s.onload = resolve; document.head.appendChild(s);
  });
  initMap();
  renderChips();
  renderLegend();
  await loadData();
  applyFiltersAndRender();
})();
</script>
</body>
</html>
